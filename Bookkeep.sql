CREATE TABLE Client (
   client_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   first_name VARCHAR2(100),
   last_name VARCHAR2(100),
   city VARCHAR2(20),
   contact VARCHAR2(20) NOT NULL,
   email VARCHAR2(40) NOT NULL UNIQUE CHECK (REGEXP_LIKE(email, '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')),
   country VARCHAR2(3)
);

CREATE TABLE  Account  (
   account_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   account_name  VARCHAR2(15),
   account_type  VARCHAR2(15),
   description  CLOB
);

-- TRANSACTION TRIGGER IS DONE
CREATE TABLE  Transaction  (
   transaction_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   transac_date  DATE NOT NULL,
   description  CLOB,
   client_id  NUMBER NOT NULL,
  CONSTRAINT  FK_Transaction_Client_id 
    FOREIGN KEY ( client_id )
      REFERENCES  Client ( client_id )
)PARTITION BY RANGE (transac_date) INTERVAL ( NUMTOYMINTERVAL (1, 'MONTH')) (
  PARTITION p_transac_date_initials VALUES LESS THAN (TO_DATE('2023-01-01', 'YYYY-MM-DD')) --paritioned by date
);

CREATE TABLE  Detail (
   detail_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   account_id  NUMBER NOT NULL,
   transaction_id  NUMBER NOT NULL,
   amount  NUMBER(10,2) NOT NULL,
   debit_credit  VARCHAR2(10) NOT NULL CHECK (debit_credit IN  ('DEBIT', 'CREDIT')),
  CONSTRAINT  FK_Detail_transaction_id 
    FOREIGN KEY ( transaction_id )
      REFERENCES  Transaction ( transaction_id ),
  CONSTRAINT  FK_Detail_account_id 
    FOREIGN KEY ( account_id )
      REFERENCES  Account ( account_id )
)PARTITION BY HASH (transaction_id) 
PARTITIONS 8; -- partitioned by transaction_id for query join reason

CREATE TABLE ChangeLog (
    log_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR2(50) NOT NULL,
    operation_type VARCHAR2(10) CHECK (operation_type IN ('INSERT', 'UPDATE', 'DELETE')),
    record_id NUMBER NOT NULL,
    change_data CLOB, -- JSON/XML for old and new values
    changed_by VARCHAR2(50), -- User who made the change
    change_time TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Transaction update Trigger 
CREATE OR REPLACE TRIGGER log_transaction
AFTER INSERT OR UPDATE OR DELETE ON Transaction
FOR EACH ROW
BEGIN

  DECLARE
    v_change_data CLOB;
  BEGIN
      -- Initialize change_data to an empty JSON object
    v_change_data := '{}'; -- Initialize as an empty JSON object
    
    IF INSERTING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by)
        VALUES ('Transaction', 'INSERT', :NEW.transaction_id, NULL, USER);

    ELSIF UPDATING THEN
      -- Append changes for 'total_amount'
      IF :OLD.transac_date != :NEW.transac_date THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('total_amount' VALUE JSON_OBJECT('old' VALUE :OLD.transac_date, 'new' VALUE :NEW.transac_date))
        );
      END IF;

      -- Append changes for 'description'
      IF :OLD.description != :NEW.description THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('description' VALUE JSON_OBJECT('old' VALUE :OLD.description, 'new' VALUE :NEW.description))
        );
      END IF;

      -- Append changes for 'client_id'
      IF :OLD.client_id != :NEW.client_id THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('client_id' VALUE JSON_OBJECT('old' VALUE :OLD.client_id, 'new' VALUE :NEW.client_id))
        );
      END IF;

      -- If any column has been changed, log the change
      IF v_change_data != {} THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Transaction', 'UPDATE', :NEW.transaction_id, v_change_data, USER, SYSDATE);
      END IF;

 ELSIF DELETING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Transaction', 'DELETE', :OLD.transaction_id,
                JSON_OBJECT('old_data' VALUE JSON_OBJECT('transac_date' VALUE :OLD.transac_date, 'description' VALUE :OLD.description, 'client_id' VALUE :OLD.client_id)),
                USER, SYSDATE);
    END IF;

  END;
END;

-- Transaction update Trigger 
CREATE OR REPLACE TRIGGER log_Detail
AFTER INSERT OR UPDATE OR DELETE ON Detail
FOR EACH ROW
BEGIN

  DECLARE
    v_change_data CLOB;
  BEGIN
      -- Initialize change_data to an empty JSON object
    v_change_data := '{}'; -- Initialize as an empty JSON object
    
    IF INSERTING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by)
        VALUES ('Detail', 'INSERT', :NEW.detail_id, NULL, USER);

    ELSIF UPDATING THEN
      -- Append changes for 'total_amount'
      IF :OLD.account_id != :NEW.account_id THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('account_id' VALUE JSON_OBJECT('old' VALUE :OLD.account_id, 'new' VALUE :NEW.account_id))
        );
      END IF;

      -- Append changes for 'description'
      IF :OLD.transaction_id != :NEW.transaction_id THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('transaction_id' VALUE JSON_OBJECT('old' VALUE :OLD.transaction_id, 'new' VALUE :NEW.transaction_id))
        );
      END IF;

      -- Append changes for 'client_id'
      IF :OLD.amount != :NEW.amount THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('amount' VALUE JSON_OBJECT('old' VALUE :OLD.amount, 'new' VALUE :NEW.amount))
        );
      END IF;

      IF :OLD.debit_credit != :NEW.debit_credit THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('debit_credit' VALUE JSON_OBJECT('old' VALUE :OLD.debit_credit, 'new' VALUE :NEW.debit_credit))
        );
      END IF;

      -- If any column has been changed, log the change
      IF v_change_data != {} THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Detail', 'UPDATE', :NEW.detail_id, v_change_data, USER, SYSDATE);
      END IF;

 ELSIF DELETING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Detail', 'DELETE', :OLD.detail_id,
                JSON_OBJECT('old_data' VALUE JSON_OBJECT('account_id' VALUE :OLD.account_id, 'transaction_id' VALUE :OLD.transaction_id, 'amount' VALUE :OLD.amount, 'debit_credit' VALUE :OLD.debit_credit)),
                USER, SYSDATE);
    END IF;

  END;
END;

-- Transaction update Trigger 
CREATE OR REPLACE TRIGGER log_Client
AFTER INSERT OR UPDATE OR DELETE ON Client
FOR EACH ROW
BEGIN

  DECLARE
    v_change_data CLOB;
  BEGIN
      -- Initialize change_data to an empty JSON object
    v_change_data := '{}'; -- Initialize as an empty JSON object
    
    IF INSERTING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by)
        VALUES ('Client', 'INSERT', :NEW.client_id, NULL, USER);

    ELSIF UPDATING THEN
      -- Append changes for 'total_amount'
      IF :OLD.first_name != :NEW.first_name THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('first_name' VALUE JSON_OBJECT('old' VALUE :OLD.first_name, 'new' VALUE :NEW.first_name))
        );
      END IF;

      -- Append changes for 'description'
      IF :OLD.city != :NEW.city THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('city' VALUE JSON_OBJECT('old' VALUE :OLD.city, 'new' VALUE :NEW.city))
        );
      END IF;

      -- Append changes for 'client_id'
      IF :OLD.last_name != :NEW.last_name THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('last_name' VALUE JSON_OBJECT('old' VALUE :OLD.last_name, 'new' VALUE :NEW.last_name))
        );
      END IF;

      IF :OLD.contact != :NEW.contact THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('contact' VALUE JSON_OBJECT('old' VALUE :OLD.contact, 'new' VALUE :NEW.contact))
        );
      END IF;

        IF :OLD.email != :NEW.email THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('email' VALUE JSON_OBJECT('old' VALUE :OLD.email, 'new' VALUE :NEW.email))
        );
      END IF;

      IF :OLD.country != :NEW.country THEN
        v_change_data := JSON_MERGE_PATCH(
          v_change_data,
          JSON_OBJECT('country' VALUE JSON_OBJECT('old' VALUE :OLD.country, 'new' VALUE :NEW.country))
        );
      END IF;

      -- If any column has been changed, log the change
      IF v_change_data != {} THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Client', 'UPDATE', :NEW.client_id, v_change_data, USER, SYSDATE);
      END IF;

 ELSIF DELETING THEN
        INSERT INTO ChangeLog (table_name, operation_type, record_id, change_data, changed_by, change_time)
        VALUES ('Client', 'DELETE', :OLD.client_id,
                JSON_OBJECT('old_data' VALUE JSON_OBJECT('first_name' VALUE :OLD.first_name, 'last_name' VALUE :OLD.last_name, 'city' VALUE :OLD.city, 'contact' VALUE :OLD.contact, 'country' VALUE :OLD.country, 'email' VALUE :OLD.email)),
                USER, SYSDATE);
    END IF;

  END;
END;

CREATE INDEX idx_client ON client(first_name, last_name);
CREATE INDEX idx_transaction_client_id ON Transaction(client_id);
CREATE INDEX idx_details_acount_dc ON Detail(debit_credit,acount);

--General Journal
CREATE OR REPLACE VIEW General_journal AS
SELECT 
      t.transac_date,
      t.description,
      acount.account_name,
      d.amount,
      d.debit_credit
FROM  Transaction t
JOIN  Detail d 
ON    t.transaction_id = d.transaction_id
JOIN  Account a
ON    a.account_id = d.account_id
ORDER BY t.transac_date;

-- General Legder 
CREATE OR REPLACE VIEW General_ledger AS
SELECT
      t.transac_date,
      a.account_name,
      t.client_id,
      CASE
        WHEN lower(d.debit_credit) = 'debit' then  t.total_amount
        ELSE NULL
      END AS Debit,
      CASE
        WHEN lower(d.debit_credit) = 'debit' then  ' '
        ELSE NULL
      END AS Credit
FROM  Transaction t
JOIN  Detail d 
ON    t.transaction_id = d.transaction_id
JOIN  Account a
ON    a.account_id = d.account_id
ORDER BY t.transac_date;

-- Trial Balance
CREATE OR REPLACE VIEW Trial_Balance AS
SELECT
      x.account_name,
    CASE
        WHEN SUM(x.Debit) > SUM(x.Credit) 
            THEN SUM(x.Debit) - SUM(x.Credit)
        ELSE NULL
    END AS Debit,
    CASE
      WHEN SUM(x.Credit) > SUM(x.Debit) 
          THEN SUM(x.Credit) - SUM(x.Debit)
      ELSE NULL
    END AS Credit
      
FROM  (SELECT
      a.account_name,
      t.client_id,
      CASE
        WHEN lower(d.debit_credit) = 'debit' then  t.total_amount
        ELSE 0
      END AS Debit,
      CASE
        WHEN lower(d.debit_credit) = 'credit' then  t.total_amount
        ELSE 0
      END AS Credit
FROM  Transaction t
JOIN  Detail d 
ON    t.transaction_id = d.transaction_id
JOIN  Account a
ON    a.account_id = d.account_id
) x 
GROUP BY x.account_name
ORDER BY x.account_name;
